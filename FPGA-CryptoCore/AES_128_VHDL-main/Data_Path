--------------------------------------------------------------------------------
-- File: CryptoCore_Data_Path.vhd
-- Description: Module d'intégration du Data Path. Connecte l'Input FIFO,
--              l'AES Engine, et l'Output FIFO. Gère l'interface de Statut
--              (data_ready, output_fifo_not_full) pour l'Unité de Contrôle (FSM).
-- Groupe: 3 (Data Path & FIFO Team)
--------------------------------------------------------------------------------
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.NUMERIC_STD.ALL;

-- Définitions des paramètres du projet (Doivent être cohérentes partout)
package constants_pkg is
    constant C_DATA_WIDTH : integer := 128; -- Largeur des blocs AES (128 bits)
    constant C_FIFO_DEPTH : integer := 64;  -- Profondeur choisie pour les buffers
end package constants_pkg;
library work;
use work.constants_pkg.all;

entity CryptoCore_Data_Path is
    port (
        -- Connexions de BASE
        clk              : in std_logic;
        reset            : in std_logic;

        -- COMMANDES de la FSM (Reçues du Groupe 4)
        fsm_read_enable  : in std_logic;       -- Permet la lecture du Input FIFO
        fsm_write_enable : in std_logic;       -- Permet l'écriture dans l'Output FIFO
        fsm_start_enc    : in std_logic;       -- Démarre un cycle de chiffrement AES
        
        -- SIGNATURES du Data Path (Envoyées vers la FSM)
        data_ready           : out std_logic;  -- Input FIFO non vide
        output_fifo_not_full : out std_logic;  -- Output FIFO non plein (Anti-Overflow)
        ciphertext_ready     : out std_logic;  -- L'AES a fini de chiffrer un bloc

        -- Connexions externes (Ports de données d'entrée/sortie du CryptoCore)
        data_in_from_source : in std_logic_vector(C_DATA_WIDTH-1 downto 0);
        data_out_to_sink    : out std_logic_vector(C_DATA_WIDTH-1 downto 0)
    );
end entity CryptoCore_Data_Path;

architecture Structure of CryptoCore_Data_Path is
    
    -- 1. Déclaration des Composants (Importation des modules des autres groupes/fichiers)
    
    -- a) Déclaration de notre propre FIFO (utiliser l'entité 'fifo' que vous avez fournie)
    component fifo is
        generic (DATA_WIDTH : integer := C_DATA_WIDTH; DEPTH : integer := C_FIFO_DEPTH);
        port (
            clk, rst, write_en, read_en : in std_logic;
            data_in  : in std_logic_vector(DATA_WIDTH-1 downto 0);
            data_out : out std_logic_vector(DATA_WIDTH-1 downto 0);
            full, empty : out std_logic
        );
    end component fifo;

    -- b) Déclaration du composant AES (Doit être fourni par le Groupe 1)
    component AES_Engine is
        port (
            clk, reset, start_enc : in std_logic;
            data_in      : in std_logic_vector(C_DATA_WIDTH-1 downto 0);
            data_out     : out std_logic_vector(C_DATA_WIDTH-1 downto 0);
            key_in       : in std_logic_vector(C_DATA_WIDTH-1 downto 0); -- Doit être géré
            ciphertext_ready : out std_logic
        );
    end component AES_Engine; -- NOTE: Vous devez gérer la clé, simplifiée ici pour le Data Path

    -- 2. Signaux internes (Les "fils" qui connectent les composants)
    signal input_fifo_data_out : std_logic_vector(C_DATA_WIDTH-1 downto 0); -- Données allant à l'AES
    signal aes_data_out        : std_logic_vector(C_DATA_WIDTH-1 downto 0); -- Données chiffrées
    
    signal input_empty_flag    : std_logic;
    signal output_full_flag    : std_logic;
    
    -- Simplification : Clé fixe ou provenant d'un autre module (PRNG/Control Unit)
    signal internal_key_bus    : std_logic_vector(C_DATA_WIDTH-1 downto 0) := (others => '0'); 

begin
    
    -- 1. INSTANCE : Input FIFO (Buffering de l'entrée)
    -- Rôle : Prend les données du drone et les envoie à l'AES sur commande de la FSM.
    Input_UUT : component fifo
        generic map (DATA_WIDTH => C_DATA_WIDTH, DEPTH => C_FIFO_DEPTH)
        port map (
            clk => clk,
            rst => reset,
            write_en => '1', -- Simplification : On suppose que la source écrit en continu si possible
            read_en => fsm_read_enable,       -- Contrôlé par la FSM
            data_in => data_in_from_source,
            data_out => input_fifo_data_out,  -- Connecté à l'AES
            full => open,                     -- Non utilisé ici, mais peut être utile
            empty => input_empty_flag         -- Signal VITAL pour la FSM
        );
        
    -- 2. INSTANCE : AES Engine (Moteur de Chiffrement)
    -- Rôle : Exécute la transformation des données.
    AES_UUT : component AES_Engine
        port map (
            clk => clk,
            reset => reset,
            start_enc => fsm_start_enc,       -- Contrôlé par la FSM
            data_in => input_fifo_data_out,   -- Données provenant du Input FIFO
            data_out => aes_data_out,         -- Données chiffrées sortantes
            key_in => internal_key_bus,       -- Clé (à connecter au PRNG/Key Management)
            ciphertext_ready => ciphertext_ready -- Statut envoyé à la FSM
        );

    -- 3. INSTANCE : Output FIFO (Buffering de la sortie)
    -- Rôle : Stocke le chiffré en attente de transmission. Assure l'anti-overflow.
    Output_UUT : component fifo
        generic map (DATA_WIDTH => C_DATA_WIDTH, DEPTH => C_FIFO_DEPTH)
        port map (
            clk => clk,
            rst => reset,
            write_en => fsm_write_enable,     -- Contrôlé par la FSM (anti-Overflow)
            read_en => '1',                   -- Simplification : La sortie lit en continu si possible
            data_in => aes_data_out,          -- Données chiffrées provenant de l'AES
            data_out => data_out_to_sink,
            full => output_full_flag,         -- Signal VITAL pour la FSM (Sécurité)
            empty => open                     -- Non utilisé par la FSM principale
        );
        
    -- 4. LOGIQUE D'INTERFACE DE CONTRÔLE (Rôle du Groupe 3 pour le Groupe 4)
    
    -- Conversion du statut 'empty' en 'data_ready' (Disponible)
    -- data_ready = '1' seulement si le FIFO n'est PAS vide
    data_ready <= NOT input_empty_flag; 
    
    -- Conversion du statut 'full' en 'output_fifo_not_full' (Place disponible)
    -- output_fifo_not_full = '1' seulement si le FIFO n'est PAS plein
    output_fifo_not_full <= NOT output_full_flag;
    
end Structure;
